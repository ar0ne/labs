/*
 *1.Вычислить максимальное количество чисел, которые можно представить
 * в двоичной системе восьмиразрядным числом.
2. Сколькими способами можно составить трехцветный полосатый флаг, если
имеется материал пяти различных цветов?
3. Сколькими способами можно составить набор из 8 пирожных, если имеется
4 сорта пирожных?
4. Сколько существует перестановок элементов 1, 2, ...,n , в которых элемент
 1 находится не на своём месте?
5. При опросе 13 человек, каждый из которых знает, по крайней мере, один иностранный
 язык, выяснилось, что 10 человек знают английский язык, 7 - немецкий,
 6 - испанский, 5 - английский и немецкий, 4 - английский и испанский,
 3 - немецкий и испанский. Сколько человек знают: а) все три языка?
 б) ровно два языка? в) только английский?
*/
/*
 *1. Написать программу генерации перестановок (рекурсивный вариант).
 * Четные номера – реализуют лексикографический порядок генерации.
 * Нечетные номера – реализуют антилексикографический порядок генерации.
  2. Написать  программу генерации k- элементных подмножеств n-элементного
  множества в  лексикографическом порядке. Вход: k – мощность подмножества,
  n - мощность множества.
*/


#include <iostream>
#include <cstring>

using namespace std;

void DoReverse(int *, int );
void MakeAntilex(int *, int);


int N;

///////////// FIRST TASK /////////////////////////
void FunctionAntilexTrans(void){
    cout<<"Input power of перестановок \n";
    cin>>N;

    int *mass = new int[N];

    for(int i=0; i<N; i++){
        mass[i]=i+1;
    }

    MakeAntilex(mass, N-1);
//    DoReverse(mass,N-1);
    //MakeLex(M,N-1);
}

void MakeAntilex(int *M, int size){
    if(!size){
        for(int i=0; i<N; i++){
            cout<<M[i]<<" ";
        }
        cout<<endl;
    }else{
        for(int i=0; i<=size; i++){
            MakeAntilex(M,size-1);
            if(i<size){
                swap(M[i],M[size]);
                DoReverse(M,size-1);
            }
        }
    }
}

void DoReverse(int *M, int size){
    int i=0, j = size;
    while(i < j){
        swap(M[i],M[j]);
        i++;
        j--;
    }
}

///////// SECOND TASK //////////////////////


///////// dijkstra ////////////////////////////////////
///
///http://acmp.ru/index.asp?main=task&id_task=132
///

/*

    Дан ориентированный взвешенный граф. Для него вам необходимо найти кратчайшее расстояние от вершины S до вершины F.
Входные данные

В первой строке входного файла INPUT.TXT записаны три числа: N, S и F (1 <= N <= 100; 1 <= S, F <= N),
где N - количество вершин графа. В следующих N строках записаны по N чисел - матрица смежности графа,
где число в i-ой строке j-ом столбце соответствует ребру из i в j: -1 означает отсутствие ребра между вершинами,
а любое неотрицательное целое число (от 0 до 100) - наличие ребра данного веса .
 На главной диагонали матрицы всегда записаны нули.
Выходные данные

В выходной файл OUTPUT.TXT необходимо вывести искомое расстояние или -1, если пути между указанными вершинами не существует.
Пример
№	INPUT.TXT	OUTPUT.TXT
3  1   2           6
0 -1   2
3  0  -1
-1 4    0

 */

#include <fstream>
#include <vector>
//#define INF 9999
/////////////////////////////////////////////////////////
int main(){

    ifstream in("input");
    ofstream out("output");

    const int INF = 1000000000;


        int n,s;
        cin >> n >> s;
        int temp;

        vector < vector < pair<int,int> > > g (n);
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cin>>temp;
                if(i == j || temp < 0) break;
                else {
                    g[i].push_back(make_pair(j,temp));
                }
            }
        }


        vector<int> d (n, INF),  p (n);
        d[s] = 0;
        vector<char> u (n);
        for (int i=0; i<n; ++i) {
            int v = -1;
            for (int j=0; j<n; ++j)
                if (!u[j] && (v == -1 || d[j] < d[v]))
                    v = j;
            if (d[v] == INF)
                break;
            u[v] = true;

            for (size_t j=0; j<g[v].size(); ++j) {
                int to = g[v][j].first,
                    len = g[v][j].second;
                if (d[v] + len < d[to]) {
                    d[to] = d[v] + len;
                    p[to] = v;
                }
            }
        }


    return 0;
}
